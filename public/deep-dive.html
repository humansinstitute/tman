<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>tman</title>
    <link rel="icon" type="image/png" href="tman_icon.png">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Wingman">
    <link rel="apple-touch-icon" href="tman_icon.png">
    
    <!-- Android/Chrome -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#059669">
    
    <!-- Windows -->
    <meta name="msapplication-TileColor" content="#059669">
    <meta name="msapplication-TileImage" content="tman_icon.png">
    
    <!-- Xterm.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables for theming */
        :root {
            /* Light theme (default) */
            --bg-gradient-start: #f9f9f9;
            --bg-gradient-end: #f5f5f0;
            --bg-primary: #ffffff;
            --bg-secondary: #fafaf9;
            --bg-tertiary: #f5f5f4;
            --text-primary: #1c1917;
            --text-secondary: #44403c;
            --text-tertiary: #57534e;
            --text-muted: #78716c;
            --text-disabled: #a8a29e;
            --border-primary: #e7e5e4;
            --border-secondary: #d6d3d1;
            --accent-primary: #059669;
            --accent-secondary: #047857;
            --accent-tertiary: #065f46;
            --accent-light: #d1fae5;
            --error-primary: #dc2626;
            --error-light: #fef2f2;
            --warning-primary: #d97706;
            --warning-light: #fffbeb;
            --success-primary: #059669;
            --success-light: #f0fdf4;
            --shadow-light: rgba(0, 0, 0, 0.04);
            --shadow-medium: rgba(0, 0, 0, 0.1);
            --shadow-strong: rgba(0, 0, 0, 0.15);
        }

        /* Dark theme */
        body.dark-theme {
            --bg-gradient-start: #1c1917;
            --bg-gradient-end: #292524;
            --bg-primary: #1c1917;
            --bg-secondary: #292524;
            --bg-tertiary: #44403c;
            --text-primary: #fafaf9;
            --text-secondary: #e7e5e4;
            --text-tertiary: #d6d3d1;
            --text-muted: #a8a29e;
            --text-disabled: #78716c;
            --border-primary: #44403c;
            --border-secondary: #57534e;
            --accent-primary: #10b981;
            --accent-secondary: #059669;
            --accent-tertiary: #047857;
            --accent-light: #064e3b;
            --error-primary: #ef4444;
            --error-light: #450a0a;
            --warning-primary: #f59e0b;
            --warning-light: #451a03;
            --success-primary: #10b981;
            --success-light: #064e3b;
            --shadow-light: rgba(0, 0, 0, 0.2);
            --shadow-medium: rgba(0, 0, 0, 0.3);
            --shadow-strong: rgba(0, 0, 0, 0.4);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--bg-primary);
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-sm);
        }

        .header h1 {
            color: var(--text-primary);
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .nav-links {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .nav-link:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2rem;
            max-width: 100%;
            margin: 0 auto;
            width: 100%;
        }

        .terminal-wrapper {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow-medium);
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 500px;
        }

        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .terminal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* TMUX control buttons */
        .tmux-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            position: relative;
        }
        
        .tmux-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .tmux-dropdown-btn {
            background: var(--accent-light);
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }
        
        .tmux-dropdown-btn:hover {
            background: var(--accent-primary);
            color: white;
        }
        
        .tmux-dropdown-btn::after {
            content: '▼';
            font-size: 0.7rem;
        }
        
        .tmux-dropdown-content {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            box-shadow: var(--shadow-medium);
            z-index: 1000;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .tmux-dropdown.open .tmux-dropdown-content {
            display: block;
        }
        
        .tmux-cmd {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
        }
        
        .tmux-cmd:last-child {
            border-bottom: none;
        }
        
        .tmux-cmd:hover {
            background: var(--accent-light);
            color: var(--accent-primary);
        }
        
        .tmux-cmd-key {
            font-family: Monaco, Menlo, monospace;
            background: var(--bg-tertiary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        .tmux-cmd-desc {
            flex: 1;
            margin-left: 0.75rem;
            color: var(--text-primary);
        }
        
        .tmux-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-primary);
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }
        /* Make arrow buttons 50% wider horizontally */
        #tmux-left, #tmux-up, #tmux-down, #tmux-right {
            padding: 0.375rem 1.125rem;
        }
        
        .tmux-btn:hover {
            background: var(--accent-light);
            color: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        .tmux-btn:active {
            transform: scale(0.95);
        }
        
        .tmux-btn.prefix {
            background: var(--accent-light);
            color: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        .tmux-btn.cancel {
            background: var(--error-light);
            color: var(--error-primary);
            border-color: var(--error-primary);
        }

        .terminal-container {
            flex: 1;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            min-height: 400px;
        }
        
        /* PIN Entry Overlay */

        .login-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .login-overlay.hidden {
            display: none;
        }

        .login-card {
            background: var(--bg-primary);
            color: var(--text-primary);
            padding: 2rem;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            max-width: 420px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .login-card h2 {
            margin: 0;
        }

        .login-actions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .login-button {
            background: var(--accent-primary);
            color: #fff;
            border: none;
            border-radius: 10px;
            padding: 0.85rem 1rem;
            font-weight: 600;
            cursor: pointer;
        }

        .login-button.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .bunker-row {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .bunker-row input {
            width: 100%;
            padding: 0.7rem 0.85rem;
            border: 1px solid var(--border-secondary);
            border-radius: 10px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .login-error {
            color: var(--error-primary);
            min-height: 1.2em;
            font-size: 0.9rem;
        }

        .pin-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 8px;
        }
        
        .pin-overlay.hidden {
            display: none;
        }
        
        .pin-container {
            text-align: center;
            padding: 2rem;
        }
        
        .pin-title {
            color: #d4d4d4;
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
        }
        
        .pin-input-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
            justify-content: center;
        }
        
        .pin-input {
            background: #2a2a2a;
            border: 1px solid #404040;
            color: #d4d4d4;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-size: 16px;
            width: 200px;
            font-family: Monaco, Menlo, monospace;
            letter-spacing: 0.1em;
            text-align: center;
        }
        
        .pin-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.1);
        }
        
        .pin-submit {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .pin-submit:hover {
            background: var(--accent-secondary);
        }
        
        .pin-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pin-error {
            color: var(--error-primary);
            font-size: 0.875rem;
            margin-top: 1rem;
            min-height: 1.25rem;
        }

        #terminal {
            height: 100%;
            width: 100%;
            padding: 0.5rem;
        }
        
        /* Override xterm.js default styles for better integration */
        .xterm {
            height: 100%;
            padding: 0.5rem;
        }
        
        .xterm-viewport {
            background-color: transparent !important;
        }
        
        .xterm-screen {
            height: 100% !important;
        }

        .connection-status {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0.75rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .connection-status.connected {
            background: var(--success-light);
            color: var(--success-primary);
        }

        .connection-status.disconnected {
            background: var(--error-light);
            color: var(--error-primary);
        }

        .connection-status.connecting {
            background: var(--warning-light);
            color: var(--warning-primary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
            }
            
            .header h1 {
                font-size: 1.1rem;
            }
            
            .logo {
                width: 24px;
                height: 24px;
            }
            
            .container {
                padding: 0.5rem;
            }
            
            .terminal-wrapper {
                padding: 0.75rem;
                border-radius: 8px;
            }
            
            .terminal-header {
                margin-bottom: 0.5rem;
                padding-bottom: 0.5rem;
                flex-wrap: wrap;
            }
            
            .terminal-title {
                display: none; /* Hide title on mobile */
            }
            
            /* Show TMUX controls on mobile */
            .tmux-controls {
                display: flex;
                flex-wrap: wrap;
                width: 100%;
                justify-content: flex-start;
                gap: 0.25rem;
                order: 1;
            }
            
            .tmux-btn {
                padding: 0.375rem 0.5rem;
                font-size: 0.65rem;
                flex: 0 0 auto;
                min-width: auto;
            }
            /* Arrow buttons 50% wider than mobile default */
            #tmux-left, #tmux-up, #tmux-down, #tmux-right {
                padding: 0.375rem 0.75rem;
            }
            
            .tmux-dropdown-btn {
                font-size: 0.65rem;
                padding: 0.375rem 0.5rem;
            }
            
            .connection-status {
            position: relative;
                order: 2;
                width: 100%;
                margin-top: 0.5rem;
                justify-content: center;
            }
            
            .terminal-container {
                min-height: 300px;
                border-radius: 6px;
            }
            
            #terminal {
                padding: 0.25rem;
            }
            
            .xterm {
                padding: 0.25rem;
            }
            
            .nav-link {
                padding: 0.375rem 0.75rem;
                font-size: 0.8rem;
            }
            
            .connection-status {
            position: relative;
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }
            
            .status-dot {
                width: 6px;
                height: 6px;
            }
            
            /* PIN overlay adjustments for mobile */
            .pin-container {
                padding: 1.5rem;
            }
            
            .pin-title {
                font-size: 1.1rem;
                margin-bottom: 1rem;
            }
            
            .pin-input-wrapper {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .pin-input {
                width: 100%;
                max-width: 200px;
                font-size: 0.9rem;
                padding: 0.625rem 0.875rem;
            }
            
            .pin-submit {
                width: 100%;
                max-width: 200px;
                font-size: 0.8rem;
                padding: 0.625rem 1.25rem;
            }
        }
        
        /* Prevent iOS zoom on input focus */
        input[type="text"],
        input[type="password"], 
        input[type="email"],
        input[type="number"],
        input[type="search"],
        textarea,
        select {
            font-size: 16px !important;
            transform-origin: left top;
            transition: none !important;
            -webkit-text-size-adjust: 100%;
        }
        
        /* Mobile specific zoom prevention */
        @media (max-width: 768px) {
            input[type="text"],
            input[type="password"], 
            input[type="email"],
            input[type="number"],
            input[type="search"],
            textarea,
            select,
            .pin-input {
                font-size: 16px !important;
                -webkit-text-size-adjust: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Header removed to maximize terminal space -->

    <div id="login-overlay" class="login-overlay hidden">
        <div class="login-card">
            <h2>Sign in to tman</h2>
            <p>Choose how to sign via Nostr. We’ll remember this device for 1 week and refresh daily.</p>
            <div class="login-actions">
                <button id="login-extension" class="login-button">Sign with Nostr extension</button>
                <div class="bunker-row">
                    <label for="bunker-npub" style="font-size: 0.9rem; color: var(--text-muted);">Paste bunker auth code</label>
                    <input id="bunker-npub" type="text" placeholder="bunker://..." aria-label="Bunker auth code">
                    <button id="login-bunker" class="login-button secondary">Use bunker</button>
                </div>
                <div id="login-error" class="login-error"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="terminal-wrapper">
            <div class="terminal-header">
                <div class="terminal-title">tman</div>
                <div class="tmux-controls">
                    <div class="tmux-dropdown" id="tmux-dropdown">
                        <button class="tmux-dropdown-btn" id="tmux-dropdown-btn">
                            <span>TMUX</span>
                        </button>
                        <div class="tmux-dropdown-content" id="tmux-dropdown-content">
                            <div class="tmux-cmd" data-cmd="detach">
                                <span class="tmux-cmd-key">⌃B D</span>
                                <span class="tmux-cmd-desc">Detach Session</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="zoom">
                                <span class="tmux-cmd-key">⌃B Z</span>
                                <span class="tmux-cmd-desc">Zoom Pane</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="vsplit">
                                <span class="tmux-cmd-key">⌃B %</span>
                                <span class="tmux-cmd-desc">Vertical Split</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="hsplit">
                                <span class="tmux-cmd-key">⌃B "</span>
                                <span class="tmux-cmd-desc">Horizontal Split</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="kill">
                                <span class="tmux-cmd-key">⌃B X</span>
                                <span class="tmux-cmd-desc">Kill Pane</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="list">
                                <span class="tmux-cmd-key">⌃B S</span>
                                <span class="tmux-cmd-desc">List Sessions</span>
                            </div>

                                <div class="tmux-cmd" data-cmd="logout" id="tmux-logout">
                                    <span class="tmux-cmd-key">logout</span>
                                    <span class="tmux-cmd-desc" id="tmux-user-npub">Not signed in</span>
                                </div>
                            <div class="tmux-cmd" data-cmd="windows">
                                <span class="tmux-cmd-key">⌃B W</span>
                                <span class="tmux-cmd-desc">List Windows</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="newwindow">
                                <span class="tmux-cmd-key">⌃B C</span>
                                <span class="tmux-cmd-desc">New Window</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="nextwindow">
                                <span class="tmux-cmd-key">⌃B N</span>
                                <span class="tmux-cmd-desc">Next Window</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="prevwindow">
                                <span class="tmux-cmd-key">⌃B P</span>
                                <span class="tmux-cmd-desc">Previous Window</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="left">
                                <span class="tmux-cmd-key">←</span>
                                <span class="tmux-cmd-desc">Left Arrow</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="up">
                                <span class="tmux-cmd-key">↑</span>
                                <span class="tmux-cmd-desc">Up Arrow</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="down">
                                <span class="tmux-cmd-key">↓</span>
                                <span class="tmux-cmd-desc">Down Arrow</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="right">
                                <span class="tmux-cmd-key">→</span>
                                <span class="tmux-cmd-desc">Right Arrow</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="shifttab">
                                <span class="tmux-cmd-key">⇧Tab</span>
                                <span class="tmux-cmd-desc">Shift+Tab</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="clear">
                                <span class="tmux-cmd-key">clear</span>
                                <span class="tmux-cmd-desc">Clear Screen</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="tman">
                                <span class="tmux-cmd-key">tman</span>
                                <span class="tmux-cmd-desc">Run Wingman</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="copy">
                                <span class="tmux-cmd-key">copy</span>
                                <span class="tmux-cmd-desc">Copy Terminal Content</span>
                            </div>
                            <div class="tmux-cmd" data-cmd="paste">
                                <span class="tmux-cmd-key">paste</span>
                                <span class="tmux-cmd-desc">Paste from Clipboard</span>
                            </div>
                        </div>
                    </div>
                    <button id="tmux-escape" class="tmux-btn" title="Send Escape">
                        <span>Esc</span>
                    </button>
                    <button id="tmux-tab" class="tmux-btn" title="Send Tab">
                        <span>Tab</span>
                    </button>
                    <button id="tmux-left" class="tmux-btn" title="Send Left Arrow">
                        <span>←</span>
                    </button>
                    <button id="tmux-up" class="tmux-btn" title="Send Up Arrow">
                        <span>↑</span>
                    </button>
                    <button id="tmux-down" class="tmux-btn" title="Send Down Arrow">
                        <span>↓</span>
                    </button>
                    <button id="tmux-right" class="tmux-btn" title="Send Right Arrow">
                        <span>→</span>
                    </button>
                    <button id="tmux-return" class="tmux-btn" title="Send Return/Enter">
                        <span>rtrn</span>
                    </button>
                    <button id="tmux-cancel" class="tmux-btn cancel" title="Send Ctrl+C (Cancel/Interrupt)">
                        <span>⌃C</span>
                        <span>Cancel</span>
                    </button>
                </div>
                <div id="connection-status" class="connection-status connecting">
                    <span class="status-dot"></span>
                    <span>Connecting...</span>
                </div>
            </div>
            <div class="terminal-container">
                <div id="pin-overlay" class="pin-overlay">
                    <div class="pin-container">
                        <div class="pin-title">Enter PIN to unlock</div>
                        <div class="pin-input-wrapper">
                            <input 
                                type="password" 
                                id="pin-input" 
                                class="pin-input" 
                                placeholder="Enter PIN"
                                maxlength="10"
                                autocomplete="off"
                            />
                            <button id="pin-submit" class="pin-submit">Connect</button>
                        </div>
                        <div id="pin-error" class="pin-error"></div>
                    </div>
                </div>
                <div id="terminal"></div>
            </div>
        </div>
    </div>

    <!-- Xterm.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.7.2/dist/socket.io.js"></script>

    <script type="module">
        import { NostrConnectSigner, RelayPool } from '/vendor/bunker-client.js';
        import { getEventHash, verifyEvent, nip19 } from 'https://esm.sh/nostr-tools@2.7.0';
        
        class LoginManager {
            constructor() {
                this.tokenKey = 'tmanSession';
                this.weekMs = 7 * 24 * 60 * 60 * 1000;
                this.dayMs = 24 * 60 * 60 * 1000;
                this.overlay = document.getElementById('login-overlay');
                this.error = document.getElementById('login-error');
                this.btnExtension = document.getElementById('login-extension');
                this.btnBunker = document.getElementById('login-bunker');
                this.bunkerInput = document.getElementById('bunker-npub');
                this.callbacks = [];
                this.token = null;
                this.metadata = { name: 'tman', url: window.location.origin };
                this.logoutButton = document.getElementById('tmux-logout');
                this.userNpubLabel = document.getElementById('tmux-user-npub');
                this.connectionStatus = document.getElementById('connection-status');
                this.pool = new RelayPool();
            }

            onAuthenticated(cb) {
                this.callbacks.push(cb);
                if (this.token) {
                    cb(this.token);
                }
            }

            async init() {
                this.bind();
                const existing = this.getToken();
                if (existing && this.isValid(existing) && this.verifyStored(existing)) {
                    this.refreshIfNeeded(existing);
                    this.token = existing;
                    this.overlay.classList.add('hidden');
                    this.callbacks.forEach((cb) => cb(existing));
                } else {
                    this.overlay.classList.remove('hidden');
                }
            }

            bind() {
                if (this.btnExtension) {
                    this.btnExtension.addEventListener('click', () => this.loginExtension());
                }
                if (this.btnBunker) {
                    this.btnBunker.addEventListener('click', () => this.loginBunker());
                }
                if (this.logoutButton) {
                    this.logoutButton.addEventListener('click', () => this.logout());
                }
            }

            setError(msg) {
                if (this.error) {
                    this.error.textContent = msg || '';
                }
            }

            getToken() {
                try {
                    const raw = localStorage.getItem(this.tokenKey);
                    return raw ? JSON.parse(raw) : null;
                } catch (_) {
                    return null;
                }
            }

            saveToken(token) {
                this.token = token;
                localStorage.setItem(this.tokenKey, JSON.stringify(token));
                this.overlay.classList.add('hidden');
                this.setError('');
                const npub = token?.pubkey ? (nip19?.npubEncode ? nip19.npubEncode(token.pubkey) : token.pubkey) : 'unknown';
                console.log(`[login] authenticated as ${npub}`);
                this.updateMenu(token);
                this.callbacks.forEach((cb) => cb(token));
            }

            isValid(token) {
                return token && token.expiresAt && Date.now() < token.expiresAt;
            }

            refreshIfNeeded(token) {
                if (!token) return;
                const remaining = token.expiresAt - Date.now();
                if (remaining < this.dayMs) {
                    token.expiresAt = Date.now() + this.weekMs;
                    this.saveToken(token);
                }
            }

            createChallenge() {
                const bytes = new Uint8Array(16);
                crypto.getRandomValues(bytes);
                return Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('');
            }

            buildChallengeEvent(challenge) {
                return {
                    kind: 27235,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['challenge', challenge]],
                    content: `tman-login:${challenge}`
                };
            }

            async signWithExtension() {
                if (!window.nostr?.signEvent || !window.nostr?.getPublicKey) {
                    throw new Error('No Nostr extension detected');
                }
                const challenge = this.createChallenge();
                let event = this.buildChallengeEvent(challenge);
                event.pubkey = await window.nostr.getPublicKey();
                const signed = await window.nostr.signEvent(event);
                signed.id = signed.id || getEventHash(signed);
                if (!verifyEvent(signed)) {
                    throw new Error('Signature verification failed');
                }
                return {
                    method: 'extension',
                    pubkey: signed.pubkey,
                    challenge,
                    issuedAt: Date.now(),
                    expiresAt: Date.now() + this.weekMs,
                    event: signed
                };
            }

            async signWithBunker() {
                const code = (this.bunkerInput?.value || '').trim();
                if (!code || !code.startsWith('bunker')) {
                    throw new Error('Paste a valid bunker code (bunker://…)');
                }
                const signer = await NostrConnectSigner.fromBunkerURI(code, {
                    metadata: this.metadata,
                    pool: this.pool
                });
                const challenge = this.createChallenge();
                let event = this.buildChallengeEvent(challenge);
                event.pubkey = await signer.getPublicKey();
                const signed = await signer.signEvent(event);
                signed.id = signed.id || getEventHash(signed);
                if (!verifyEvent(signed)) {
                    throw new Error('Signature verification failed');
                }
                try {
                    if (typeof signer.disconnect === 'function') {
                        await signer.disconnect();
                    }
                } catch (_) {}
                return {
                    method: 'bunker',
                    pubkey: signed.pubkey,
                    challenge,
                    issuedAt: Date.now(),
                    expiresAt: Date.now() + this.weekMs,
                    event: signed
                };
            }

            verifyStored(token) {
                try {
                    if (!token?.event) return false;
                    return verifyEvent(token.event);
                } catch (_) {
                    return false;
                }
            }


            updateMenu(token) {
                const npub = token?.pubkey ? (nip19?.npubEncode ? nip19.npubEncode(token.pubkey) : token.pubkey) : 'unknown';
                if (this.userNpubLabel) this.userNpubLabel.textContent = npub;
            }

            logout() {
                try {
                    localStorage.removeItem(this.tokenKey);
                } catch (_) {}
                this.token = null;
                if (this.userNpubLabel) this.userNpubLabel.textContent = 'Not signed in';
                if (this.overlay) this.overlay.classList.remove('hidden');
                this.callbacks = [];
                // Optionally clear PIN auth state
                const pinInput = document.getElementById('pin-input');
                const pinOverlay = document.getElementById('pin-overlay');
                const pinError = document.getElementById('pin-error');
                const pinSubmit = document.getElementById('pin-submit');
                if (pinOverlay) pinOverlay.classList.remove('hidden');
                if (pinError) pinError.textContent = '';
                if (pinSubmit) pinSubmit.disabled = false;
                if (pinInput) pinInput.value = '';
            }

            async loginExtension() {
                this.setError('');
                try {
                    const token = await this.signWithExtension();
                    this.saveToken(token);
                } catch (err) {
                    this.setError(err?.message || 'Extension sign-in failed');
                }
            }

            loginBunker() {
                this.setError('');
                this.signWithBunker()
                    .then((token) => this.saveToken(token))
                    .catch((err) => this.setError(err?.message || 'Bunker sign-in failed'));
            }
        }

        class TerminalClient {
            constructor() {
                this.terminal = null;
                this.socket = null;
                this.connectionStatus = document.getElementById('connection-status');
                this.pinOverlay = document.getElementById('pin-overlay');
                this.pinInput = document.getElementById('pin-input');
                this.pinSubmit = document.getElementById('pin-submit');
                this.pinError = document.getElementById('pin-error');
                this.authenticated = false;
                
                // TMUX control buttons
                this.tmuxDropdown = document.getElementById('tmux-dropdown');
                this.tmuxDropdownBtn = document.getElementById('tmux-dropdown-btn');
                this.tmuxDropdownContent = document.getElementById('tmux-dropdown-content');
                this.tmuxEscape = document.getElementById('tmux-escape');
                this.tmuxTab = document.getElementById('tmux-tab');
                this.tmuxLeft = document.getElementById('tmux-left');
                this.tmuxUp = document.getElementById('tmux-up');
                this.tmuxDown = document.getElementById('tmux-down');
                this.tmuxRight = document.getElementById('tmux-right');
                this.tmuxReturn = document.getElementById('tmux-return');
                this.tmuxCancel = document.getElementById('tmux-cancel');
                
                this.init();
            }

            init() {
                this.setupPinEntry();
                this.setupTerminal();
                this.setupSocket();
                this.setupTmuxControls();
            }
            
            setupTmuxControls() {
                // Helper function to provide visual feedback
                const flashButton = (button) => {
                    const originalBg = button.style.background;
                    const originalColor = button.style.color;
                    button.style.background = 'var(--accent-primary)';
                    button.style.color = 'white';
                    setTimeout(() => {
                        button.style.background = originalBg;
                        button.style.color = originalColor;
                    }, 200);
                };
                
                // Dropdown toggle
                if (this.tmuxDropdownBtn) {
                    this.tmuxDropdownBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        console.log('Dropdown button clicked');
                        this.tmuxDropdown.classList.toggle('open');
                    });
                }
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (this.tmuxDropdown && !this.tmuxDropdown.contains(e.target)) {
                        this.tmuxDropdown.classList.remove('open');
                    }
                });
                
                // TMUX command handlers
                if (this.tmuxDropdownContent) {
                    this.tmuxDropdownContent.addEventListener('click', (e) => {
                        const cmd = e.target.closest('[data-cmd]');
                        if (cmd && this.authenticated && this.socket && this.socket.connected) {
                            const command = cmd.dataset.cmd;
                            console.log('TMUX command clicked:', command);
                            this.executeTmuxCommand(command);
                            this.tmuxDropdown.classList.remove('open');
                        }
                    });
                }
                
                // Escape button
                if (this.tmuxEscape) {
                    this.tmuxEscape.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxEscape);
                            // Send Escape character
                            this.socket.emit('terminal-input', '\x1b');
                        }
                    });
                }
                
                // Tab button
                if (this.tmuxTab) {
                    this.tmuxTab.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxTab);
                            // Send Tab character
                            this.socket.emit('terminal-input', '\t');
                        }
                    });
                }
                
                // Left arrow button
                if (this.tmuxLeft) {
                    this.tmuxLeft.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxLeft);
                            // Send Left arrow escape sequence
                            this.socket.emit('terminal-input', '\x1b[D');
                        }
                    });
                }
                
                // Up arrow button
                if (this.tmuxUp) {
                    this.tmuxUp.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxUp);
                            // Send Up arrow escape sequence
                            this.socket.emit('terminal-input', '\x1b[A');
                        }
                    });
                }
                
                // Down arrow button
                if (this.tmuxDown) {
                    this.tmuxDown.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxDown);
                            // Send Down arrow escape sequence
                            this.socket.emit('terminal-input', '\x1b[B');
                        }
                    });
                }
                
                // Right arrow button
                if (this.tmuxRight) {
                    this.tmuxRight.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxRight);
                            // Send Right arrow escape sequence
                            this.socket.emit('terminal-input', '\x1b[C');
                        }
                    });
                }
                
                // Return button
                if (this.tmuxReturn) {
                    this.tmuxReturn.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxReturn);
                            // Send Return/Enter character
                            this.socket.emit('terminal-input', '\r');
                        }
                    });
                }
                
                // Cancel button (Ctrl+C)
                if (this.tmuxCancel) {
                    this.tmuxCancel.addEventListener('click', () => {
                        if (this.authenticated && this.socket && this.socket.connected) {
                            flashButton(this.tmuxCancel);
                            // Send Ctrl+C (ASCII code 3)
                            this.socket.emit('terminal-input', '\x03');
                        }
                    });
                }
            }
            
            getVisibleTerminalContent() {
                if (!this.terminal) return '';
                
                try {
                    // Get all visible content from the terminal buffer
                    const lines = [];
                    const buffer = this.terminal.buffer.active;
                    
                    for (let i = 0; i < buffer.length; i++) {
                        const line = buffer.getLine(i);
                        if (line) {
                            lines.push(line.translateToString());
                        }
                    }
                    
                    // Join lines and remove excessive empty lines at the end
                    return lines.join('\n').replace(/\n+$/, '\n');
                } catch (err) {
                    console.error('Error getting terminal content:', err);
                    // Fallback: try to get content from DOM
                    try {
                        const terminalElement = document.querySelector('.xterm-screen');
                        if (terminalElement) {
                            return terminalElement.textContent || terminalElement.innerText || '';
                        }
                    } catch (domErr) {
                        console.error('Error getting terminal content from DOM:', domErr);
                    }
                    return '';
                }
            }
            
            executeTmuxCommand(command) {
                if (!this.authenticated || !this.socket || !this.socket.connected) {
                    return;
                }
                
                // Flash the dropdown button for feedback
                this.tmuxDropdownBtn.style.background = 'var(--accent-primary)';
                this.tmuxDropdownBtn.style.color = 'white';
                setTimeout(() => {
                    this.tmuxDropdownBtn.style.background = '';
                    this.tmuxDropdownBtn.style.color = '';
                }, 200);
                
                const prefix = '\x02'; // Ctrl+B
                
                switch (command) {
                    case 'detach':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 'd'), 100);
                        break;
                    case 'zoom':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 'z'), 100);
                        break;
                    case 'vsplit':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', '%'), 100);
                        break;
                    case 'hsplit':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', '"'), 100);
                        break;
                    case 'kill':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 'x'), 100);
                        break;
                    case 'list':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 's'), 100);
                        break;
                    case 'windows':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 'w'), 100);
                        break;
                    case 'newwindow':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 'c'), 100);
                        break;
                    case 'nextwindow':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 'n'), 100);
                        break;
                    case 'prevwindow':
                        this.socket.emit('terminal-input', prefix);
                        setTimeout(() => this.socket.emit('terminal-input', 'p'), 100);
                        break;
                    case 'up':
                        this.socket.emit('terminal-input', '\x1b[A'); // Up arrow escape sequence
                        break;
                    case 'down':
                        this.socket.emit('terminal-input', '\x1b[B'); // Down arrow escape sequence
                        break;
                    case 'left':
                        this.socket.emit('terminal-input', '\x1b[D'); // Left arrow escape sequence
                        break;
                    case 'right':
                        this.socket.emit('terminal-input', '\x1b[C'); // Right arrow escape sequence
                        break;
                    case 'shifttab':
                        this.socket.emit('terminal-input', '\x1b[Z'); // Shift+Tab escape sequence
                        break;
                    case 'clear':
                        this.socket.emit('terminal-input', 'clear\r');
                        break;
                    case 'tman':
                        // Send tman command directly (uses TERMINALCMD from server env)
                        this.socket.emit('terminal-input', 'tman\\r');
                        break;
                    case 'copy':
                        // Copy terminal content to clipboard
                        this.copyTerminalContent();
                        break;
                    case 'paste':
                        // Paste from clipboard to terminal
                        this.pasteToTerminal();
                        break;
                }
            }
            
            async copyTerminalContent() {
                if (!this.authenticated || !this.terminal) {
                    console.log('Cannot copy: not authenticated or terminal not ready');
                    return;
                }
                
                try {
                    // Get the selected text first, then fall back to visible content
                    const selectedText = this.terminal.getSelection();
                    const visibleText = selectedText || this.getVisibleTerminalContent();
                    
                    if (!visibleText) {
                        console.log('No content to copy');
                        return;
                    }
                    
                    // Try modern clipboard API first
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        try {
                            await navigator.clipboard.writeText(visibleText);
                            console.log(`Copied ${visibleText.length} characters to clipboard`);
                            return;
                        } catch (clipboardErr) {
                            console.log('Modern clipboard API failed, trying fallback:', clipboardErr.message);
                        }
                    }
                    
                    // Fallback for mobile/older browsers - create a temporary textarea
                    const textArea = document.createElement('textarea');
                    textArea.value = visibleText;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        const successful = document.execCommand('copy');
                        if (successful) {
                            console.log(`Copied ${visibleText.length} characters to clipboard (fallback method)`);
                        } else {
                            console.error('Copy command failed');
                        }
                    } catch (execErr) {
                        console.error('execCommand copy failed:', execErr);
                    } finally {
                        document.body.removeChild(textArea);
                    }
                    
                } catch (err) {
                    console.error('Failed to copy terminal contents:', err);
                }
            }
            
            async pasteToTerminal() {
                if (!this.authenticated || !this.socket || !this.socket.connected) {
                    console.log('Cannot paste: not authenticated or socket not connected');
                    return;
                }
                
                // First, try to focus the terminal to enable paste events
                const terminalElement = document.getElementById('terminal');
                if (terminalElement) {
                    terminalElement.focus();
                    this.terminal.focus();
                }
                
                try {
                    let text = '';
                    
                    // Try modern clipboard API first (works best on desktop)
                    if (navigator.clipboard && navigator.clipboard.readText) {
                        try {
                            text = await navigator.clipboard.readText();
                            if (text) {
                                this.processPastedText(text);
                                return;
                            }
                        } catch (clipboardErr) {
                            console.log('Modern clipboard API failed for reading:', clipboardErr.message);
                        }
                    }
                    
                    // Fallback: Create a temporary input element for mobile compatibility
                    console.log('Using fallback paste method for mobile compatibility...');
                    this.createPasteHelper();
                    
                } catch (err) {
                    console.error('Failed to paste from clipboard:', err);
                    // Final fallback - show instructions
                    this.showPasteInstructions();
                }
            }
            
            processPastedText(text) {
                if (!text) return;
                
                // Focus the terminal first
                this.terminal.focus();
                
                // Process text for better terminal compatibility
                const processedText = text
                    .replace(/\r\n/g, '\r')  // Convert Windows line endings
                    .replace(/\n/g, '\r');   // Convert Unix line endings to carriage returns
                
                // Send the clipboard text to terminal via socket
                this.socket.emit('terminal-input', processedText);
                console.log(`Pasted ${processedText.length} characters to terminal`);
            }
            
            createPasteHelper() {
                // Visible overlay for iOS/mobile paste compatibility
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed';
                overlay.style.inset = '0';
                overlay.style.background = 'rgba(0,0,0,0.55)';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.zIndex = '9999';

                const panel = document.createElement('div');
                panel.style.width = 'min(680px, 92vw)';
                panel.style.background = '#111827';
                panel.style.border = '1px solid #374151';
                panel.style.borderRadius = '12px';
                panel.style.boxShadow = '0 10px 24px rgba(0,0,0,0.35)';
                panel.style.padding = '16px';
                panel.style.color = '#e5e7eb';

                const title = document.createElement('div');
                title.textContent = 'Paste Into Terminal';
                title.style.fontWeight = '600';
                title.style.marginBottom = '8px';
                title.style.fontSize = '16px';

                const hint = document.createElement('div');
                hint.textContent = 'Tap the field below and use Paste. The text will be sent to the terminal.';
                hint.style.fontSize = '14px';
                hint.style.color = '#9ca3af';
                hint.style.marginBottom = '10px';

                const ta = document.createElement('textarea');
                ta.rows = 6;
                ta.placeholder = 'Tap here, then Paste…';
                ta.style.width = '100%';
                ta.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                ta.style.fontSize = '16px'; // Avoid iOS zoom
                ta.style.lineHeight = '1.4';
                ta.style.padding = '10px 12px';
                ta.style.borderRadius = '8px';
                ta.style.border = '1px solid #4b5563';
                ta.style.background = '#0b1220';
                ta.style.color = '#e5e7eb';
                ta.autocapitalize = 'off';
                ta.autocorrect = 'off';
                ta.spellcheck = false;

                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.gap = '8px';
                actions.style.marginTop = '10px';
                actions.style.justifyContent = 'flex-end';

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.background = '#374151';
                cancelBtn.style.border = '1px solid #4b5563';
                cancelBtn.style.color = '#e5e7eb';
                cancelBtn.style.padding = '8px 12px';
                cancelBtn.style.borderRadius = '8px';
                cancelBtn.style.cursor = 'pointer';

                const sendBtn = document.createElement('button');
                sendBtn.textContent = 'Send';
                sendBtn.style.background = '#059669';
                sendBtn.style.border = '1px solid #059669';
                sendBtn.style.color = '#ffffff';
                sendBtn.style.padding = '8px 12px';
                sendBtn.style.borderRadius = '8px';
                sendBtn.style.cursor = 'pointer';

                const cleanup = () => {
                    document.body.style.overflow = '';
                    overlay.remove();
                    // Refocus terminal after closing
                    setTimeout(() => {
                        const terminalElement = document.getElementById('terminal');
                        if (terminalElement) {
                            terminalElement.focus();
                            this.terminal.focus();
                        }
                    }, 30);
                };

                cancelBtn.addEventListener('click', cleanup);
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) cleanup();
                });

                const submit = () => {
                    const text = ta.value;
                    if (text && text.trim().length) {
                        this.processPastedText(text);
                    }
                    cleanup();
                };
                sendBtn.addEventListener('click', submit);

                // Auto-send after paste gesture lands content
                ta.addEventListener('paste', () => setTimeout(submit, 0));

                panel.appendChild(title);
                panel.appendChild(hint);
                panel.appendChild(ta);
                actions.appendChild(cancelBtn);
                actions.appendChild(sendBtn);
                panel.appendChild(actions);
                overlay.appendChild(panel);
                document.body.appendChild(overlay);
                document.body.style.overflow = 'hidden';

                // Focus after mount so caret shows; user still must tap Paste
                setTimeout(() => ta.focus(), 50);
            }
            
            showPasteInstructions() {
                console.log('Please use one of these methods to paste:');
                console.log('1. Right-click on the terminal and select "Paste"');
                console.log('2. Use Ctrl+V (or Cmd+V on Mac) while focused on the terminal');
                console.log('3. Use your device\'s paste gesture or menu');
            }
            
            setupPinEntry() {
                // Handle PIN submission
                const submitPin = () => {
                    const pin = this.pinInput.value.trim();
                    if (pin) {
                        this.pinError.textContent = '';
                        this.pinSubmit.disabled = true;
                        this.socket.emit('authenticate', { pin, pubkey: this.token?.pubkey || null });
                    }
                };
                
                this.pinSubmit.addEventListener('click', submitPin);
                
                this.pinInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        submitPin();
                    }
                });
                
                // Focus on PIN input when page loads
                setTimeout(() => this.pinInput.focus(), 100);
            }

            setupTerminal() {
                // Check if mobile
                const isMobile = window.innerWidth <= 768;
                
                // Create terminal instance with responsive settings
                this.terminal = new Terminal({
                    cursorBlink: true,
                    theme: {
                        background: '#1a1a1a',
                        foreground: '#d4d4d4',
                        cursor: '#10b981',
                        selection: 'rgba(16, 185, 129, 0.3)',
                        black: '#000000',
                        red: '#dc2626',
                        green: '#10b981',
                        yellow: '#d97706',
                        blue: '#3b82f6',
                        magenta: '#a855f7',
                        cyan: '#06b6d4',
                        white: '#e5e5e5',
                        brightBlack: '#737373',
                        brightRed: '#ef4444',
                        brightGreen: '#22c55e',
                        brightYellow: '#f59e0b',
                        brightBlue: '#60a5fa',
                        brightMagenta: '#c084fc',
                        brightCyan: '#22d3ee',
                        brightWhite: '#ffffff'
                    },
                    fontSize: isMobile ? 11 : 14,
                    fontFamily: 'Monaco, Menlo, "Ubuntu Mono", Consolas, monospace',
                    scrollback: 1000,
                    convertEol: true,
                    // Allow text selection on mobile
                    allowProposedApi: true,
                    // Better mobile scrolling
                    scrollSensitivity: isMobile ? 3 : 1
                });

                // Open terminal in the container
                this.terminal.open(document.getElementById('terminal'));

                // Handle user input
                this.terminal.onData((data) => {
                    if (this.socket && this.socket.connected && this.authenticated) {
                        this.socket.emit('terminal-input', data);
                    }
                });

                // Handle terminal resize
                this.terminal.onResize((dimensions) => {
                    if (this.socket && this.socket.connected) {
                        this.socket.emit('terminal-resize', dimensions);
                    }
                });

                // Auto-resize terminal on window resize
                window.addEventListener('resize', () => {
                    this.resizeTerminal();
                });
                
                // Add paste event listener for mobile compatibility
                this.terminal.attachCustomKeyEventHandler((event) => {
                    // Handle Ctrl+V or Cmd+V paste
                    if ((event.ctrlKey || event.metaKey) && event.key === 'v' && event.type === 'keydown') {
                        event.preventDefault();
                        this.pasteToTerminal();
                        return false;
                    }
                    return true;
                });
                
                // Also listen for paste events on the terminal element
                const terminalElement = document.getElementById('terminal');
                if (terminalElement) {
                    terminalElement.addEventListener('paste', (event) => {
                        event.preventDefault();
                        const clipboardData = event.clipboardData || window.clipboardData;
                        if (clipboardData) {
                            const text = clipboardData.getData('text');
                            if (text && this.authenticated && this.socket && this.socket.connected) {
                                this.processPastedText(text);
                                console.log('Pasted via paste event');
                            }
                        }
                    });
                }

                // Initial resize
                setTimeout(() => this.resizeTerminal(), 100);
            }

            resizeTerminal() {
                const container = document.querySelector('.terminal-container');
                if (!container) return;
                
                const rect = container.getBoundingClientRect();
                
                // Get computed styles for more accurate measurements
                const computedStyle = window.getComputedStyle(container);
                const paddingX = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
                const paddingY = parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
                
                const availableWidth = rect.width - paddingX;
                const availableHeight = rect.height - paddingY;
                
                // Check if mobile viewport
                const isMobile = window.innerWidth <= 768;
                
                // Adjust character size calculations based on device
                let charWidth, charHeight, minCols, minRows;
                
                if (isMobile) {
                    // Mobile settings - smaller font requires different calculations
                    charWidth = 6.8;  // Even smaller character width for mobile
                    charHeight = 14;  // Smaller line height for mobile
                    minCols = 35;     // Allow even narrower terminal on mobile
                    minRows = 20;     // Allow shorter terminal on mobile
                } else {
                    // Desktop settings
                    charWidth = 8.4;
                    charHeight = 17;
                    minCols = 80;
                    minRows = 24;
                }
                
                // Calculate terminal dimensions based on container size
                const cols = Math.floor(availableWidth / charWidth);
                const rows = Math.floor(availableHeight / charHeight);
                
                // Apply minimum dimensions based on device
                const finalCols = Math.max(minCols, cols);
                const finalRows = Math.max(minRows, rows);
                
                this.terminal.resize(finalCols, finalRows);
                
                // Also update font size on mobile
                if (isMobile && this.terminal.options.fontSize !== 11) {
                    this.terminal.options.fontSize = 11;
                } else if (!isMobile && this.terminal.options.fontSize !== 14) {
                    this.terminal.options.fontSize = 14;
                }
            }

            setupSocket() {
                // Connect to the terminal namespace
                this.socket = io('/terminal');

                this.socket.on('connect', () => {
                    console.log('Connected to terminal socket');
                    this.updateConnectionStatus('connecting', 'Checking authentication...');
                });
                
                // Handle authentication status check
                this.socket.on('auth-required', () => {
                    console.log('PIN entry required');
                    this.pinOverlay.classList.remove('hidden');
                    this.updateConnectionStatus('connecting', 'Enter PIN');
                    setTimeout(() => this.pinInput.focus(), 100);
                });
                
                this.socket.on('auth-success', () => {
                    console.log('Authentication successful');
                    this.authenticated = true;
                    this.pinOverlay.classList.add('hidden');
                    this.updateConnectionStatus('connected', 'Connected');
                    
                    // Get current terminal dimensions
                    const dimensions = {
                        cols: this.terminal.cols,
                        rows: this.terminal.rows
                    };
                    
                    // Start the terminal session with tman command and dimensions
                    this.socket.emit('start-terminal', dimensions);
                    
                    // Focus on terminal
                    this.terminal.focus();
                });
                
                this.socket.on('auth-failed', (message) => {
                    console.log('Authentication failed:', message);
                    this.pinError.textContent = message || 'Invalid PIN';
                    this.pinSubmit.disabled = false;
                    this.pinInput.value = '';
                    this.pinInput.focus();
                });

                this.socket.on('disconnect', () => {
                    console.log('Disconnected from terminal');
                    this.updateConnectionStatus('disconnected', 'Disconnected');
                    this.authenticated = false;
                    
                    // Show PIN overlay again on disconnect
                    this.pinOverlay.classList.remove('hidden');
                    this.pinSubmit.disabled = false;
                    this.pinInput.value = '';
                    this.pinError.textContent = '';
                });

                // Handle session state events
                this.socket.on('session-fresh', () => {
                    console.log('Terminal session started with tman');
                    // Could add UI indication that tman is starting
                });

                this.socket.on('terminal-output', (data) => {
                    this.terminal.write(data);
                });

                this.socket.on('terminal-error', (error) => {
                    this.terminal.write(`\r\n\x1b[31mError: ${error}\x1b[0m\r\n`);
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Connection error:', error);
                    this.updateConnectionStatus('disconnected', 'Connection Error');
                });
            }

            updateConnectionStatus(status, text) {
                this.connectionStatus.className = `connection-status ${status}`;
                const npubLabel = this.userNpubLabel?.textContent || '';
                this.connectionStatus.innerHTML = `
                    <span class="status-dot"></span>
                    <span>${text}</span>
                `;
                if (this.userNpubLabel && npubLabel) {
                    this.userNpubLabel.textContent = npubLabel;
                }
            }
        }

        // Initialize terminal when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const login = new LoginManager();
            login.onAuthenticated(() => {
                new TerminalClient();
            });
            login.init();
            
            // Prevent mobile zoom
            preventMobileZoom();
        });
        
        function preventMobileZoom() {
            // Additional prevention for mobile zoom
            document.addEventListener('touchstart', function(event) {
                if (event.touches.length > 1) {
                    event.preventDefault();
                }
            }, { passive: false });
            
            // Prevent double-tap zoom
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, { passive: false });
            
            // Set font size to 16px for all inputs to prevent iOS zoom
            const inputs = document.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
                if (!input.style.fontSize || parseFloat(input.style.fontSize) < 16) {
                    input.style.fontSize = '16px';
                }
            });
        }

        // Handle dark theme based on system preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.add('dark-theme');
        }

        // Listen for theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (e.matches) {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.remove('dark-theme');
            }
        });
    </script>
</body>
</html>
